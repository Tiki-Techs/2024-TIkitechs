package frc.robot.subsystems;

import org.apache.commons.math3.analysis.interpolation.SplineInterpolator;
import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction;

import com.revrobotics.CANSparkBase.ControlType;
import com.revrobotics.CANSparkFlex;
import com.revrobotics.CANSparkLowLevel.MotorType;
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkPIDController;

import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Constants.HoodConstants;
import frc.robot.Constants.ShooterConstants;
import frc.robot.RobotContainer;
import frc.robot.commands.swervedrive.HoodPositioner;

public class Shooter extends SubsystemBase {

    CANSparkFlex m_leader = new CANSparkFlex(ShooterConstants.m_LeaderID, MotorType.kBrushless);
    CANSparkFlex m_Follower = new CANSparkFlex(ShooterConstants.m_FollowerID, MotorType.kBrushless);

    DigitalInput IRSensor = new DigitalInput(Constants.ShooterConstants.IRSensor);
    public CANSparkMax index = new CANSparkMax(ShooterConstants.m_IndexID, MotorType.kBrushless);
    public SparkPIDController m_pidController;
    private RelativeEncoder m_encoder;
    public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM;
    private static final SplineInterpolator SPLINE_INTERPOLATOR = new SplineInterpolator();
    private PolynomialSplineFunction m_shooterAngleCurve;
    private PolynomialSplineFunction m_shooterFlywheelCurve;
    public double setpoint = 0;
    private final Timer m_timer = new Timer();
    private final Timer s_timer = new Timer();
    boolean HadNote = false;

    public Shooter() {
        m_Follower.follow(m_leader, true);
        m_pidController = m_leader.getPIDController();

        // Encoder object created to display position values
        m_encoder = m_leader.getEncoder();

        // PID coefficients
        kP = 0.0018;
        kI = 0;
        kD = 0.07591;
        kIz = 0;
        kFF = 0.0001;
        kMaxOutput = 1;
        kMinOutput = -1;
        maxRPM = 5700;

        // set PID coefficients
        m_pidController.setP(kP);
        m_pidController.setI(kI);
        m_pidController.setD(kD);
        m_pidController.setIZone(kIz);
        m_pidController.setFF(kFF);
        m_pidController.setOutputRange(kMinOutput, kMaxOutput);

        // load the shooter map
        var shooterMap = ShooterConstants.SHOOTER_MAP;
        double[] distances = new double[shooterMap.size()];
        double[] flywheelSpeeds = new double[shooterMap.size()];
        double[] angles = new double[shooterMap.size()];

        for (int i = 0; i < shooterMap.size(); i++) {
            distances[i] = shooterMap.get(i).getKey();
            flywheelSpeeds[i] = shooterMap.get(i).getValue().speed;
            angles[i] = shooterMap.get(i).getValue().angle;
        }

        m_shooterFlywheelCurve = SPLINE_INTERPOLATOR.interpolate(distances, flywheelSpeeds);
        m_shooterAngleCurve = SPLINE_INTERPOLATOR.interpolate(distances, angles);
        HadNote = HasNote();
        // Timer s_Timer = new Timer();
    }

    public void RunShooter(double speed) {
        // Speed is from 0 to 1, so turning it into 0 to 5700
        setpoint = speed * maxRPM;

        // auto shooting
        // sets the angle of the hood and the speed setpoint equal to the autogenerated
        // setpoints given our distance from the speaker

        if (RobotContainer.mechXbox.getRightBumper() || (!RobotContainer.overrideNoteSensor && HasNote())) {

            // we do this in case the limelight is flickery when seeing the april tag, or if
            // we want to rev up to speed before reaching the speaker.
            if (Vision.distance != 0) {
                // if we see the april tag, move the hood to position and set the speed.
                setpoint = getAutomaticState().speed;
                HoodPositioner.setpoint = getAutomaticState().angle;
            } else {
                // if we dont see the apriltag, dont move the hood, and run up to max speek
                setpoint = 5700;
            }
        }

        if ((RobotContainer.mechXbox.getAButton() || RobotContainer.mechXbox.getBButton())
                || (!RobotContainer.overrideNoteSensor && !HasNote())) {

            // while a button is pressed run index (same as intake), and firing
            index.set(-1);

        } else if (RobotContainer.mechXbox.getXButton() || RobotContainer.mechXbox.getYButton()) {
            // reverse index for outtaking
            index.set(0.5);
        } else {
            index.set(0);
        }

        // lob shot
        // sets speed to max and angle to lob angle.
        if (RobotContainer.mechXbox.getPOV() == 0) {
            setpoint = Constants.HoodConstants.LobSpeed;
            HoodPositioner.setpoint = Constants.HoodConstants.LobAngle;
        }

        if (!RobotContainer.overrideNoteSensor)

            SmartDashboard.putNumber("Shooter SetPoint", setpoint);
        SmartDashboard.putNumber("ProcessVariable", m_encoder.getVelocity());
    }

    public double getVelocity() {
        return m_encoder.getVelocity();
    }

    public void quickReverse() {
        m_timer.reset();
        m_timer.start();
        while (m_timer.get() < 0.2) {
            index.set(0.5);
        }
    }

    public Boolean HasNote() {
        return !IRSensor.get();
    }

    public State getAutomaticState() {
        var targetDistance = getTargetDistance();
        var flywheelSpeed = m_shooterFlywheelCurve.value(targetDistance);
        var angle = m_shooterAngleCurve.value(targetDistance);

        return new State(flywheelSpeed, angle);
    }

    private double getTargetDistance() {
        return Vision.distance;
    }

    @Override
    public void periodic() {
        if (HadNote != HasNote() && HasNote()) {
            s_timer.reset();
            s_timer.start();
            s_timer.get();
        }

        if (s_timer.get() < 1)

        {

            RobotContainer.driverXbox.setRumble(RumbleType.kBothRumble, 1);
        } else {

            RobotContainer.driverXbox.setRumble(RumbleType.kBothRumble, 0);
        }
        if (!RobotContainer.overrideNoteSensor) {
            setpoint = Math.max(setpoint, 2500);
        }
        if (setpoint != 0) {
            m_pidController.setReference(setpoint, ControlType.kVelocity);
        } else {
            m_leader.set(0);
        }
        HadNote = HasNote();
    }
    // SmartDashboard.putNumber("IR sensor", IRSensor.get());
    // if (HasNote = true) {
    // RobotContainer.driverXbox.setRumble(RumbleType.kBothRumble, 1)
    // }

    public static class State {
        public final double speed;
        public final double angle;

        public State(double speed, double angle) {
            this.speed = speed;
            this.angle = angle;
        }
    }

    public Command Fire() {
        return new InstantCommand(
                () -> {
                    Timer a_timer = new Timer();
                    a_timer.reset();
                    a_timer.start();
                    // stay aiming and up to speed for 0.5 seconds wile also running the index to
                    // fire the shot.
                    while (a_timer.get() < 0.5) {
                        m_pidController.setReference(5700, ControlType.kVelocity);
                        if (Vision.distance != 0) {
                            var set = Math.max(HoodConstants.lowerLimit,
                                    Math.min(getAutomaticState().angle - Constants.HoodConstants.AutoOffset,
                                            HoodConstants.upperLimit));
                            RobotContainer.positioner.m_Leader
                                    .set(RobotContainer.positioner.hoodPID
                                            .calculate(RobotContainer.s_Hood.getRotation(), set));
                        } else {
                            // if we cannot see the april tag dont run the hood that way it doesnt crash
                            // into itself.
                            RobotContainer.positioner.m_Leader.set(0);
                        }
                        index.set(-1);
                    }
                    // stop the index
                    index.set(0);
                }, this);
    }

    public Command StopShooter() {
        return new InstantCommand(() -> {
            Timer a_timer = new Timer();
            a_timer.reset();
            a_timer.start();
            m_leader.set(0);

            // stops running the firing motors and for 0.5 seconds move the hood back down
            // to the intake position
            while (a_timer.get() < 0.5) {
                m_pidController.setReference(0, ControlType.kVelocity);
                m_leader.set(0);
                if (RobotContainer.s_Hood.getRotation() < 67) {
                    RobotContainer.positioner.m_Leader
                            .set(RobotContainer.positioner.hoodPID.calculate(RobotContainer.s_Hood.getRotation(), 67));
                } else {
                    RobotContainer.positioner.m_Leader.set(0);
                }
            }
            // stop the hood
            RobotContainer.positioner.m_Leader.set(0);
        }, this);
    }

    public Command AimAuto() {
        return new InstantCommand(() -> {
            Timer a_timer = new Timer();
            a_timer.reset();
            a_timer.start();
            // for half a second starts reving up to speed and aiming at the correct angle
            while (a_timer.get() < 1) {
                m_pidController.setReference(5700, ControlType.kVelocity);

                // im not sure why we need to tell it to stop driving but we do.
                RobotContainer.drivebase.drive(new Translation2d(0,
                        0),
                        0,
                        true);

                if (Vision.distance != 0) {
                    var set = Math.max(HoodConstants.lowerLimit,
                            Math.min(getAutomaticState().angle - Constants.HoodConstants.AutoOffset,
                                    HoodConstants.upperLimit));
                    RobotContainer.positioner.m_Leader
                            .set(RobotContainer.positioner.hoodPID.calculate(RobotContainer.s_Hood.getRotation(), set));
                } else {
                    // dont run the hood if we cant see it
                    RobotContainer.positioner.m_Leader.set(0);
                }
            }
        }, this);
    }
}
